// -------------------------------------------------------------
// 
// File Name: D:\NU\OF\WHDLOFDMTransmitterExample_all_new\hdl_prj\hdlsrc3\whdlOFDMTransmitter_up_con\whdlOFDMTx\whdlOFDMTx_Data_and_Control_Signal_Generation.v
// Created: 2023-05-02 12:36:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: whdlOFDMTx_Data_and_Control_Signal_Generation
// Source Path: whdlOFDMTx/Frame Generator/Data/Data and Control Signal Generation
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module whdlOFDMTx_Data_and_Control_Signal_Generation
          (clk,
           reset,
           enb_1_2_0,
           dataSet,
           modTypeIndex,
           codeRateIndex,
           loadMod,
           trBlkSize,
           dataIn,
           wrEnable,
           resetRAM,
           data,
           start,
           end_rsvd,
           valid,
           puncVector_0,
           puncVector_1,
           puncVector_2,
           puncVector_3,
           puncVector_4,
           puncVector_5,
           puncVector_6,
           puncVector_7,
           puncVector_8,
           puncVector_9,
           modTypeInd,
           loadModulator);


  input   clk;
  input   reset;
  input   enb_1_2_0;
  input   dataSet;
  input   [1:0] modTypeIndex;  // ufix2
  input   [1:0] codeRateIndex;  // ufix2
  input   loadMod;
  input   [13:0] trBlkSize;  // ufix14
  input   dataIn;
  input   wrEnable;
  input   resetRAM;
  output  data;
  output  start;
  output  end_rsvd;
  output  valid;
  output  puncVector_0;  // boolean
  output  puncVector_1;  // boolean
  output  puncVector_2;  // boolean
  output  puncVector_3;  // boolean
  output  puncVector_4;  // boolean
  output  puncVector_5;  // boolean
  output  puncVector_6;  // boolean
  output  puncVector_7;  // boolean
  output  puncVector_8;  // boolean
  output  puncVector_9;  // boolean
  output  [1:0] modTypeInd;  // ufix2
  output  loadModulator;


  wire [13:0] count_step;  // ufix14
  wire [13:0] count_from;  // ufix14
  wire [13:0] count_reset;  // ufix14
  reg [13:0] HDL_Counter2_out1;  // ufix14
  wire [13:0] count;  // ufix14
  wire need_to_wrap;
  wire [13:0] count_value;  // ufix14
  wire [13:0] count_1;  // ufix14
  wire [13:0] count_2;  // ufix14
  reg  Delay6_out1;
  wire [13:0] count_step_1;  // ufix14
  wire [13:0] count_from_1;  // ufix14
  wire [13:0] count_reset_1;  // ufix14
  reg [13:0] HDL_Counter1_out1;  // ufix14
  wire [13:0] count_3;  // ufix14
  wire need_to_wrap_1;
  wire [13:0] count_value_1;  // ufix14
  wire [13:0] count_4;  // ufix14
  wire [13:0] count_5;  // ufix14
  wire Store_Input_Payload_Data_out1;
  wire [13:0] Constant_out1;  // ufix14
  wire signed [14:0] Add_1;  // sfix15
  wire signed [14:0] Add_2;  // sfix15
  wire signed [14:0] Add_out1;  // sfix15
  wire [13:0] Data_Type_Conversion1_out1;  // ufix14
  wire [13:0] count_step_2;  // ufix14
  wire [13:0] count_from_2;  // ufix14
  wire [13:0] count_reset_2;  // ufix14
  reg [13:0] HDL_Counter_out1;  // ufix14
  wire [13:0] count_6;  // ufix14
  wire need_to_wrap_2;
  wire [13:0] count_value_2;  // ufix14
  wire [13:0] count_7;  // ufix14
  reg [13:0] Delay_out1;  // ufix14
  wire Relational_Operator_relop1;
  reg  Delay4_out1;
  wire [13:0] count_8;  // ufix14
  reg  Delay7_out1;
  reg [13:0] Delay11_out1;  // ufix14
  wire Compare_To_Constant1_out1;
  wire Logical_Operator4_out1;
  reg [13:0] Delay5_out1;  // ufix14
  wire [13:0] Constant2_out1;  // ufix14
  wire signed [14:0] Add1_sub_temp;  // sfix15
  wire signed [14:0] Add1_1;  // sfix15
  wire signed [14:0] Add1_2;  // sfix15
  wire [13:0] Add1_out1;  // ufix14
  wire Relational_Operator2_relop1;
  reg  Delay1_out1;
  reg  Delay2_out1;
  wire puncVec_0;
  wire puncVec_1;
  wire puncVec_2;
  wire puncVec_3;
  wire puncVec_4;
  wire puncVec_5;
  wire puncVec_6;
  wire puncVec_7;
  wire puncVec_8;
  wire puncVec_9;

  // This subsystem gives out payload data bits and corresponding control signals that are to be processed by Data chain.
  // Counter is to be reset when the count reaches (trBlkSize -1). But, as there are two delays in feedback loop, 
  // the counter is made to reset when count reaches (trBlkSize - 3).


  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 9562
  assign count_step = 14'b00000000000001;



  assign count_from = 14'b00000000000000;



  assign count_reset = 14'b00000000000000;



  assign count = HDL_Counter2_out1 + count_step;



  assign need_to_wrap = HDL_Counter2_out1 == 14'b10010101011010;



  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);



  assign count_1 = (wrEnable == 1'b0 ? HDL_Counter2_out1 :
              count_value);



  assign count_2 = (resetRAM == 1'b0 ? count_1 :
              count_reset);



  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb_1_2_0) begin
          HDL_Counter2_out1 <= count_2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          Delay6_out1 <= dataSet;
        end
      end
    end



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 9561
  assign count_step_1 = 14'b00000000000001;



  assign count_from_1 = 14'b00000000000000;



  assign count_reset_1 = 14'b00000000000000;



  assign count_3 = HDL_Counter1_out1 + count_step_1;



  assign need_to_wrap_1 = HDL_Counter1_out1 == 14'b10010101011001;



  assign count_value_1 = (need_to_wrap_1 == 1'b0 ? count_3 :
              count_from_1);



  assign count_4 = (Delay6_out1 == 1'b0 ? HDL_Counter1_out1 :
              count_value_1);



  assign count_5 = (resetRAM == 1'b0 ? count_4 :
              count_reset_1);



  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb_1_2_0) begin
          HDL_Counter1_out1 <= count_5;
        end
      end
    end



  whdlOFDMTx_SimpleDualPortRAM_singlebit_block #(.AddrWidth(14),
                                                 .DataWidth(1)
                                                 )
                                               u_Store_Input_Payload_Data (.clk(clk),
                                                                           .enb_1_2_0(enb_1_2_0),
                                                                           .wr_din(dataIn),
                                                                           .wr_addr(HDL_Counter2_out1),
                                                                           .wr_en(wrEnable),
                                                                           .rd_addr(HDL_Counter1_out1),
                                                                           .rd_dout(Store_Input_Payload_Data_out1)
                                                                           );

  assign data = Store_Input_Payload_Data_out1;

  assign Constant_out1 = 14'b00000000000011;



  assign Add_1 = {1'b0, trBlkSize};
  assign Add_2 = {1'b0, Constant_out1};
  assign Add_out1 = Add_1 - Add_2;



  assign Data_Type_Conversion1_out1 = Add_out1[13:0];



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 9561
  assign count_step_2 = 14'b00000000000001;



  assign count_from_2 = 14'b00000000000000;



  assign count_reset_2 = 14'b00000000000000;



  assign count_6 = HDL_Counter_out1 + count_step_2;



  assign need_to_wrap_2 = HDL_Counter_out1 == 14'b10010101011001;



  assign count_value_2 = (need_to_wrap_2 == 1'b0 ? count_6 :
              count_from_2);



  assign count_7 = (dataSet == 1'b0 ? HDL_Counter_out1 :
              count_value_2);



  assign Relational_Operator_relop1 = Delay_out1 == Data_Type_Conversion1_out1;



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          Delay4_out1 <= Relational_Operator_relop1;
        end
      end
    end



  assign count_8 = (Delay4_out1 == 1'b0 ? count_7 :
              count_reset_2);



  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb_1_2_0) begin
          HDL_Counter_out1 <= count_8;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb_1_2_0) begin
          Delay_out1 <= HDL_Counter_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          Delay7_out1 <= Delay6_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb_1_2_0) begin
          Delay11_out1 <= Delay_out1;
        end
      end
    end



  assign Compare_To_Constant1_out1 = Delay11_out1 == 14'b00000000000000;



  assign Logical_Operator4_out1 = Delay7_out1 & Compare_To_Constant1_out1;



  assign start = Logical_Operator4_out1;

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 14'b00000000000000;
      end
      else begin
        if (enb_1_2_0) begin
          Delay5_out1 <= Delay_out1;
        end
      end
    end



  assign Constant2_out1 = 14'b00000000000001;



  assign Add1_1 = {1'b0, trBlkSize};
  assign Add1_2 = {1'b0, Constant2_out1};
  assign Add1_sub_temp = Add1_1 - Add1_2;
  assign Add1_out1 = Add1_sub_temp[13:0];



  assign Relational_Operator2_relop1 = Delay5_out1 == Add1_out1;



  assign end_rsvd = Relational_Operator2_relop1;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          Delay1_out1 <= dataSet;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          Delay2_out1 <= Delay1_out1;
        end
      end
    end



  assign valid = Delay2_out1;

  whdlOFDMTx_Select_Puncture_Vector u_Select_Puncture_Vector (.clk(clk),
                                                              .reset(reset),
                                                              .enb_1_2_0(enb_1_2_0),
                                                              .codeRate(codeRateIndex),  // ufix2
                                                              .puncVec_0(puncVec_0),  // boolean
                                                              .puncVec_1(puncVec_1),  // boolean
                                                              .puncVec_2(puncVec_2),  // boolean
                                                              .puncVec_3(puncVec_3),  // boolean
                                                              .puncVec_4(puncVec_4),  // boolean
                                                              .puncVec_5(puncVec_5),  // boolean
                                                              .puncVec_6(puncVec_6),  // boolean
                                                              .puncVec_7(puncVec_7),  // boolean
                                                              .puncVec_8(puncVec_8),  // boolean
                                                              .puncVec_9(puncVec_9)  // boolean
                                                              );

  assign puncVector_0 = puncVec_0;

  assign puncVector_1 = puncVec_1;

  assign puncVector_2 = puncVec_2;

  assign puncVector_3 = puncVec_3;

  assign puncVector_4 = puncVec_4;

  assign puncVector_5 = puncVec_5;

  assign puncVector_6 = puncVec_6;

  assign puncVector_7 = puncVec_7;

  assign puncVector_8 = puncVec_8;

  assign puncVector_9 = puncVec_9;

  assign modTypeInd = modTypeIndex;

  assign loadModulator = loadMod;

endmodule  // whdlOFDMTx_Data_and_Control_Signal_Generation

