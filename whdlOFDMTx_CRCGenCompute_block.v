// -------------------------------------------------------------
// 
// File Name: D:\NU\OF\WHDLOFDMTransmitterExample_all_new\hdl_prj\hdlsrc3\whdlOFDMTransmitter_up_con\whdlOFDMTx\whdlOFDMTx_CRCGenCompute_block.v
// Created: 2023-05-02 12:36:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: whdlOFDMTx_CRCGenCompute_block
// Source Path: whdlOFDMTx/Frame Generator/Header/General CRC Generator HDL Optimized/CRCGenCompute
// Hierarchy Level: 5
// 
// Compute the CRC CheckSum
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module whdlOFDMTx_CRCGenCompute_block
          (clk,
           reset,
           enb_1_2_0,
           datainReg,
           validIn,
           processMsg,
           padZero,
           counter,
           crcChecksum_0,
           crcChecksum_1,
           crcChecksum_2,
           crcChecksum_3,
           crcChecksum_4,
           crcChecksum_5,
           crcChecksum_6,
           crcChecksum_7,
           crcChecksum_8,
           crcChecksum_9,
           crcChecksum_10,
           crcChecksum_11,
           crcChecksum_12,
           crcChecksum_13,
           crcChecksum_14,
           crcChecksum_15);


  input   clk;
  input   reset;
  input   enb_1_2_0;
  input   datainReg;  // ufix1
  input   validIn;  // ufix1
  input   processMsg;  // ufix1
  input   padZero;  // ufix1
  input   [3:0] counter;  // ufix4
  output  crcChecksum_0;  // ufix1
  output  crcChecksum_1;  // ufix1
  output  crcChecksum_2;  // ufix1
  output  crcChecksum_3;  // ufix1
  output  crcChecksum_4;  // ufix1
  output  crcChecksum_5;  // ufix1
  output  crcChecksum_6;  // ufix1
  output  crcChecksum_7;  // ufix1
  output  crcChecksum_8;  // ufix1
  output  crcChecksum_9;  // ufix1
  output  crcChecksum_10;  // ufix1
  output  crcChecksum_11;  // ufix1
  output  crcChecksum_12;  // ufix1
  output  crcChecksum_13;  // ufix1
  output  crcChecksum_14;  // ufix1
  output  crcChecksum_15;  // ufix1


  wire xoredSel;  // ufix1
  reg  dvalidin;  // ufix1
  wire tcsSel;  // ufix1
  wire csSel;  // ufix1
  wire rpadZero;  // ufix1
  wire dataSel;  // ufix1
  wire [0:15] padingzeros;  // ufix1 [16]
  wire [0:14] inputzeros;  // ufix1 [15]
  wire [0:15] datamux;  // ufix1 [16]
  wire [0:15] datacpt;  // ufix1 [16]
  wire datacpt_15;  // ufix1
  wire datacpt_14;  // ufix1
  wire datacpt_13;  // ufix1
  wire datacpt_12;  // ufix1
  wire datacpt_11;  // ufix1
  wire datacpt_10;  // ufix1
  wire datacpt_9;  // ufix1
  wire datacpt_8;  // ufix1
  wire datacpt_7;  // ufix1
  wire datacpt_6;  // ufix1
  wire datacpt_5;  // ufix1
  wire datacpt_4;  // ufix1
  wire datacpt_3;  // ufix1
  wire datacpt_2;  // ufix1
  wire datacpt_1;  // ufix1
  wire datacpt_0;  // ufix1
  wire [0:15] finalXorValue;  // ufix1 [16]
  wire finalXorValue_0;  // ufix1
  wire finalXorValue_1;  // ufix1
  wire finalXorValue_2;  // ufix1
  wire finalXorValue_3;  // ufix1
  wire finalXorValue_4;  // ufix1
  wire finalXorValue_5;  // ufix1
  wire finalXorValue_6;  // ufix1
  wire finalXorValue_7;  // ufix1
  wire finalXorValue_8;  // ufix1
  wire finalXorValue_9;  // ufix1
  wire finalXorValue_10;  // ufix1
  wire finalXorValue_11;  // ufix1
  wire finalXorValue_12;  // ufix1
  wire finalXorValue_13;  // ufix1
  wire finalXorValue_14;  // ufix1
  wire finalXorValue_15;  // ufix1
  wire [0:15] newChecksum;  // ufix1 [16]
  wire newChecksum_0;  // ufix1
  wire refelctCheckSum_15;  // ufix1
  wire newChecksum_1;  // ufix1
  wire refelctCheckSum_14;  // ufix1
  wire newChecksum_2;  // ufix1
  wire refelctCheckSum_13;  // ufix1
  wire newChecksum_3;  // ufix1
  wire refelctCheckSum_12;  // ufix1
  wire newChecksum_4;  // ufix1
  wire refelctCheckSum_11;  // ufix1
  wire newChecksum_5;  // ufix1
  wire refelctCheckSum_10;  // ufix1
  wire newChecksum_6;  // ufix1
  wire refelctCheckSum_9;  // ufix1
  wire newChecksum_7;  // ufix1
  wire refelctCheckSum_8;  // ufix1
  wire newChecksum_8;  // ufix1
  wire refelctCheckSum_7;  // ufix1
  wire newChecksum_9;  // ufix1
  wire refelctCheckSum_6;  // ufix1
  wire newChecksum_10;  // ufix1
  wire refelctCheckSum_5;  // ufix1
  wire newChecksum_11;  // ufix1
  wire refelctCheckSum_4;  // ufix1
  wire newChecksum_12;  // ufix1
  wire refelctCheckSum_3;  // ufix1
  wire newChecksum_13;  // ufix1
  wire refelctCheckSum_2;  // ufix1
  wire newChecksum_14;  // ufix1
  wire refelctCheckSum_1;  // ufix1
  wire newChecksum_15;  // ufix1
  wire refelctCheckSum_0;  // ufix1
  wire [0:15] xoredChecksum;  // ufix1 [16]
  reg  [0:15] checksumReg;  // ufix1 [16]
  wire checksumReg_14;  // ufix1
  wire tcs_entry15;  // ufix1
  wire checksumReg_13;  // ufix1
  wire tcs_entry14;  // ufix1
  wire checksumReg_12;  // ufix1
  wire tcs_entry13;  // ufix1
  wire checksumReg_11;  // ufix1
  wire checksumReg_15;  // ufix1
  wire tcs_entry12;  // ufix1
  wire checksumReg_10;  // ufix1
  wire tcs_entry11;  // ufix1
  wire checksumReg_9;  // ufix1
  wire tcs_entry10;  // ufix1
  wire checksumReg_8;  // ufix1
  wire tcs_entry9;  // ufix1
  wire checksumReg_7;  // ufix1
  wire tcs_entry8;  // ufix1
  wire checksumReg_6;  // ufix1
  wire tcs_entry7;  // ufix1
  wire checksumReg_5;  // ufix1
  wire tcs_entry6;  // ufix1
  wire checksumReg_4;  // ufix1
  wire tcs_entry5;  // ufix1
  wire checksumReg_3;  // ufix1
  wire tcs_entry4;  // ufix1
  wire checksumReg_2;  // ufix1
  wire tcs_entry3;  // ufix1
  wire checksumReg_1;  // ufix1
  wire tcs_entry2;  // ufix1
  wire checksumReg_0;  // ufix1
  wire tcs_entry1;  // ufix1
  wire tcs_entry0;  // ufix1
  wire [0:15] tchecksum;  // ufix1 [16]
  wire [0:15] finalChecksum;  // ufix1 [16]
  reg  [0:15] crcChecksum;  // ufix1 [16]


  assign xoredSel = counter == 4'b1111;



  always @(posedge clk or posedge reset)
    begin : validin_register_process
      if (reset == 1'b1) begin
        dvalidin <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          dvalidin <= validIn;
        end
      end
    end



  assign tcsSel = processMsg & dvalidin;



  assign csSel = tcsSel | padZero;



  assign rpadZero =  ~ padZero;



  // Selection signal: Select input data or pad zeros
  assign dataSel = rpadZero & dvalidin;



  // Padding zeros
  assign padingzeros[0] = 1'b0;
  assign padingzeros[1] = 1'b0;
  assign padingzeros[2] = 1'b0;
  assign padingzeros[3] = 1'b0;
  assign padingzeros[4] = 1'b0;
  assign padingzeros[5] = 1'b0;
  assign padingzeros[6] = 1'b0;
  assign padingzeros[7] = 1'b0;
  assign padingzeros[8] = 1'b0;
  assign padingzeros[9] = 1'b0;
  assign padingzeros[10] = 1'b0;
  assign padingzeros[11] = 1'b0;
  assign padingzeros[12] = 1'b0;
  assign padingzeros[13] = 1'b0;
  assign padingzeros[14] = 1'b0;
  assign padingzeros[15] = 1'b0;



  assign inputzeros[0] = 1'b0;
  assign inputzeros[1] = 1'b0;
  assign inputzeros[2] = 1'b0;
  assign inputzeros[3] = 1'b0;
  assign inputzeros[4] = 1'b0;
  assign inputzeros[5] = 1'b0;
  assign inputzeros[6] = 1'b0;
  assign inputzeros[7] = 1'b0;
  assign inputzeros[8] = 1'b0;
  assign inputzeros[9] = 1'b0;
  assign inputzeros[10] = 1'b0;
  assign inputzeros[11] = 1'b0;
  assign inputzeros[12] = 1'b0;
  assign inputzeros[13] = 1'b0;
  assign inputzeros[14] = 1'b0;



  // Prepare inputs for parallel CRC computation
  assign datamux[0] = inputzeros[0];
  assign datamux[1] = inputzeros[1];
  assign datamux[2] = inputzeros[2];
  assign datamux[3] = inputzeros[3];
  assign datamux[4] = inputzeros[4];
  assign datamux[5] = inputzeros[5];
  assign datamux[6] = inputzeros[6];
  assign datamux[7] = inputzeros[7];
  assign datamux[8] = inputzeros[8];
  assign datamux[9] = inputzeros[9];
  assign datamux[10] = inputzeros[10];
  assign datamux[11] = inputzeros[11];
  assign datamux[12] = inputzeros[12];
  assign datamux[13] = inputzeros[13];
  assign datamux[14] = inputzeros[14];
  assign datamux[15] = datainReg;

  // Switch between input data and padded zeros
  assign datacpt[0] = (dataSel == 1'b0 ? padingzeros[0] :
              datamux[0]);
  assign datacpt[1] = (dataSel == 1'b0 ? padingzeros[1] :
              datamux[1]);
  assign datacpt[2] = (dataSel == 1'b0 ? padingzeros[2] :
              datamux[2]);
  assign datacpt[3] = (dataSel == 1'b0 ? padingzeros[3] :
              datamux[3]);
  assign datacpt[4] = (dataSel == 1'b0 ? padingzeros[4] :
              datamux[4]);
  assign datacpt[5] = (dataSel == 1'b0 ? padingzeros[5] :
              datamux[5]);
  assign datacpt[6] = (dataSel == 1'b0 ? padingzeros[6] :
              datamux[6]);
  assign datacpt[7] = (dataSel == 1'b0 ? padingzeros[7] :
              datamux[7]);
  assign datacpt[8] = (dataSel == 1'b0 ? padingzeros[8] :
              datamux[8]);
  assign datacpt[9] = (dataSel == 1'b0 ? padingzeros[9] :
              datamux[9]);
  assign datacpt[10] = (dataSel == 1'b0 ? padingzeros[10] :
              datamux[10]);
  assign datacpt[11] = (dataSel == 1'b0 ? padingzeros[11] :
              datamux[11]);
  assign datacpt[12] = (dataSel == 1'b0 ? padingzeros[12] :
              datamux[12]);
  assign datacpt[13] = (dataSel == 1'b0 ? padingzeros[13] :
              datamux[13]);
  assign datacpt[14] = (dataSel == 1'b0 ? padingzeros[14] :
              datamux[14]);
  assign datacpt[15] = (dataSel == 1'b0 ? padingzeros[15] :
              datamux[15]);



  assign datacpt_15 = datacpt[15];

  assign datacpt_14 = datacpt[14];

  assign datacpt_13 = datacpt[13];

  assign datacpt_12 = datacpt[12];

  assign datacpt_11 = datacpt[11];

  assign datacpt_10 = datacpt[10];

  assign datacpt_9 = datacpt[9];

  assign datacpt_8 = datacpt[8];

  assign datacpt_7 = datacpt[7];

  assign datacpt_6 = datacpt[6];

  assign datacpt_5 = datacpt[5];

  assign datacpt_4 = datacpt[4];

  assign datacpt_3 = datacpt[3];

  assign datacpt_2 = datacpt[2];

  assign datacpt_1 = datacpt[1];

  assign datacpt_0 = datacpt[0];

  // Compute finalXor
  assign finalXorValue[0] = 1'b0;
  assign finalXorValue[1] = 1'b0;
  assign finalXorValue[2] = 1'b0;
  assign finalXorValue[3] = 1'b0;
  assign finalXorValue[4] = 1'b0;
  assign finalXorValue[5] = 1'b0;
  assign finalXorValue[6] = 1'b0;
  assign finalXorValue[7] = 1'b0;
  assign finalXorValue[8] = 1'b0;
  assign finalXorValue[9] = 1'b0;
  assign finalXorValue[10] = 1'b0;
  assign finalXorValue[11] = 1'b0;
  assign finalXorValue[12] = 1'b0;
  assign finalXorValue[13] = 1'b0;
  assign finalXorValue[14] = 1'b0;
  assign finalXorValue[15] = 1'b0;



  assign finalXorValue_0 = finalXorValue[0];

  assign finalXorValue_1 = finalXorValue[1];

  assign finalXorValue_2 = finalXorValue[2];

  assign finalXorValue_3 = finalXorValue[3];

  assign finalXorValue_4 = finalXorValue[4];

  assign finalXorValue_5 = finalXorValue[5];

  assign finalXorValue_6 = finalXorValue[6];

  assign finalXorValue_7 = finalXorValue[7];

  assign finalXorValue_8 = finalXorValue[8];

  assign finalXorValue_9 = finalXorValue[9];

  assign finalXorValue_10 = finalXorValue[10];

  assign finalXorValue_11 = finalXorValue[11];

  assign finalXorValue_12 = finalXorValue[12];

  assign finalXorValue_13 = finalXorValue[13];

  assign finalXorValue_14 = finalXorValue[14];

  assign finalXorValue_15 = finalXorValue[15];

  assign newChecksum_0 = newChecksum[0];

  assign refelctCheckSum_15 = newChecksum_0 ^ finalXorValue_15;



  assign newChecksum_1 = newChecksum[1];

  assign refelctCheckSum_14 = newChecksum_1 ^ finalXorValue_14;



  assign newChecksum_2 = newChecksum[2];

  assign refelctCheckSum_13 = newChecksum_2 ^ finalXorValue_13;



  assign newChecksum_3 = newChecksum[3];

  assign refelctCheckSum_12 = newChecksum_3 ^ finalXorValue_12;



  assign newChecksum_4 = newChecksum[4];

  assign refelctCheckSum_11 = newChecksum_4 ^ finalXorValue_11;



  assign newChecksum_5 = newChecksum[5];

  assign refelctCheckSum_10 = newChecksum_5 ^ finalXorValue_10;



  assign newChecksum_6 = newChecksum[6];

  assign refelctCheckSum_9 = newChecksum_6 ^ finalXorValue_9;



  assign newChecksum_7 = newChecksum[7];

  assign refelctCheckSum_8 = newChecksum_7 ^ finalXorValue_8;



  assign newChecksum_8 = newChecksum[8];

  assign refelctCheckSum_7 = newChecksum_8 ^ finalXorValue_7;



  assign newChecksum_9 = newChecksum[9];

  assign refelctCheckSum_6 = newChecksum_9 ^ finalXorValue_6;



  assign newChecksum_10 = newChecksum[10];

  assign refelctCheckSum_5 = newChecksum_10 ^ finalXorValue_5;



  assign newChecksum_11 = newChecksum[11];

  assign refelctCheckSum_4 = newChecksum_11 ^ finalXorValue_4;



  assign newChecksum_12 = newChecksum[12];

  assign refelctCheckSum_3 = newChecksum_12 ^ finalXorValue_3;



  assign newChecksum_13 = newChecksum[13];

  assign refelctCheckSum_2 = newChecksum_13 ^ finalXorValue_2;



  assign newChecksum_14 = newChecksum[14];

  assign refelctCheckSum_1 = newChecksum_14 ^ finalXorValue_1;



  // Reflect Checksum and make checksum LSB first
  assign newChecksum_15 = newChecksum[15];

  assign refelctCheckSum_0 = newChecksum_15 ^ finalXorValue_0;



  assign xoredChecksum[0] = refelctCheckSum_0;
  assign xoredChecksum[1] = refelctCheckSum_1;
  assign xoredChecksum[2] = refelctCheckSum_2;
  assign xoredChecksum[3] = refelctCheckSum_3;
  assign xoredChecksum[4] = refelctCheckSum_4;
  assign xoredChecksum[5] = refelctCheckSum_5;
  assign xoredChecksum[6] = refelctCheckSum_6;
  assign xoredChecksum[7] = refelctCheckSum_7;
  assign xoredChecksum[8] = refelctCheckSum_8;
  assign xoredChecksum[9] = refelctCheckSum_9;
  assign xoredChecksum[10] = refelctCheckSum_10;
  assign xoredChecksum[11] = refelctCheckSum_11;
  assign xoredChecksum[12] = refelctCheckSum_12;
  assign xoredChecksum[13] = refelctCheckSum_13;
  assign xoredChecksum[14] = refelctCheckSum_14;
  assign xoredChecksum[15] = refelctCheckSum_15;

  assign checksumReg_14 = checksumReg[14];

  // Compute checksum element16
  assign tcs_entry15 = checksumReg_14 ^ datacpt_0;



  assign checksumReg_13 = checksumReg[13];

  // Compute checksum element15
  assign tcs_entry14 = checksumReg_13 ^ datacpt_1;



  assign checksumReg_12 = checksumReg[12];

  // Compute checksum element14
  assign tcs_entry13 = checksumReg_12 ^ datacpt_2;



  assign checksumReg_11 = checksumReg[11];

  // Compute checksum element13
  assign tcs_entry12 = datacpt_3 ^ (checksumReg_15 ^ checksumReg_11);



  assign checksumReg_10 = checksumReg[10];

  // Compute checksum element12
  assign tcs_entry11 = checksumReg_10 ^ datacpt_4;



  assign checksumReg_9 = checksumReg[9];

  // Compute checksum element11
  assign tcs_entry10 = checksumReg_9 ^ datacpt_5;



  assign checksumReg_8 = checksumReg[8];

  // Compute checksum element10
  assign tcs_entry9 = checksumReg_8 ^ datacpt_6;



  assign checksumReg_7 = checksumReg[7];

  // Compute checksum element9
  assign tcs_entry8 = checksumReg_7 ^ datacpt_7;



  assign checksumReg_6 = checksumReg[6];

  // Compute checksum element8
  assign tcs_entry7 = checksumReg_6 ^ datacpt_8;



  assign checksumReg_5 = checksumReg[5];

  // Compute checksum element7
  assign tcs_entry6 = checksumReg_5 ^ datacpt_9;



  assign checksumReg_4 = checksumReg[4];

  // Compute checksum element6
  assign tcs_entry5 = datacpt_10 ^ (checksumReg_15 ^ checksumReg_4);



  assign checksumReg_3 = checksumReg[3];

  // Compute checksum element5
  assign tcs_entry4 = checksumReg_3 ^ datacpt_11;



  assign checksumReg_2 = checksumReg[2];

  // Compute checksum element4
  assign tcs_entry3 = checksumReg_2 ^ datacpt_12;



  assign checksumReg_1 = checksumReg[1];

  // Compute checksum element3
  assign tcs_entry2 = checksumReg_1 ^ datacpt_13;



  assign checksumReg_0 = checksumReg[0];

  // Compute checksum element2
  assign tcs_entry1 = checksumReg_0 ^ datacpt_14;



  assign checksumReg_15 = checksumReg[15];

  // Compute checksum element1
  // Checksum selection signal
  assign tcs_entry0 = checksumReg_15 ^ datacpt_15;



  assign tchecksum[0] = tcs_entry0;
  assign tchecksum[1] = tcs_entry1;
  assign tchecksum[2] = tcs_entry2;
  assign tchecksum[3] = tcs_entry3;
  assign tchecksum[4] = tcs_entry4;
  assign tchecksum[5] = tcs_entry5;
  assign tchecksum[6] = tcs_entry6;
  assign tchecksum[7] = tcs_entry7;
  assign tchecksum[8] = tcs_entry8;
  assign tchecksum[9] = tcs_entry9;
  assign tchecksum[10] = tcs_entry10;
  assign tchecksum[11] = tcs_entry11;
  assign tchecksum[12] = tcs_entry12;
  assign tchecksum[13] = tcs_entry13;
  assign tchecksum[14] = tcs_entry14;
  assign tchecksum[15] = tcs_entry15;

  always @(posedge clk or posedge reset)
    begin : checksum_register_process
      if (reset == 1'b1) begin
        checksumReg[0] <= 1'b0;
        checksumReg[1] <= 1'b0;
        checksumReg[2] <= 1'b0;
        checksumReg[3] <= 1'b0;
        checksumReg[4] <= 1'b0;
        checksumReg[5] <= 1'b0;
        checksumReg[6] <= 1'b0;
        checksumReg[7] <= 1'b0;
        checksumReg[8] <= 1'b0;
        checksumReg[9] <= 1'b0;
        checksumReg[10] <= 1'b0;
        checksumReg[11] <= 1'b0;
        checksumReg[12] <= 1'b0;
        checksumReg[13] <= 1'b0;
        checksumReg[14] <= 1'b0;
        checksumReg[15] <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          if (xoredSel == 1'b1) begin
            checksumReg[0] <= 1'b0;
            checksumReg[1] <= 1'b0;
            checksumReg[2] <= 1'b0;
            checksumReg[3] <= 1'b0;
            checksumReg[4] <= 1'b0;
            checksumReg[5] <= 1'b0;
            checksumReg[6] <= 1'b0;
            checksumReg[7] <= 1'b0;
            checksumReg[8] <= 1'b0;
            checksumReg[9] <= 1'b0;
            checksumReg[10] <= 1'b0;
            checksumReg[11] <= 1'b0;
            checksumReg[12] <= 1'b0;
            checksumReg[13] <= 1'b0;
            checksumReg[14] <= 1'b0;
            checksumReg[15] <= 1'b0;
          end
          else begin
            checksumReg[0] <= finalChecksum[0];
            checksumReg[1] <= finalChecksum[1];
            checksumReg[2] <= finalChecksum[2];
            checksumReg[3] <= finalChecksum[3];
            checksumReg[4] <= finalChecksum[4];
            checksumReg[5] <= finalChecksum[5];
            checksumReg[6] <= finalChecksum[6];
            checksumReg[7] <= finalChecksum[7];
            checksumReg[8] <= finalChecksum[8];
            checksumReg[9] <= finalChecksum[9];
            checksumReg[10] <= finalChecksum[10];
            checksumReg[11] <= finalChecksum[11];
            checksumReg[12] <= finalChecksum[12];
            checksumReg[13] <= finalChecksum[13];
            checksumReg[14] <= finalChecksum[14];
            checksumReg[15] <= finalChecksum[15];
          end
        end
      end
    end



  // Update checksum register for valid inputs
  assign newChecksum[0] = (csSel == 1'b0 ? checksumReg[0] :
              tchecksum[0]);
  assign newChecksum[1] = (csSel == 1'b0 ? checksumReg[1] :
              tchecksum[1]);
  assign newChecksum[2] = (csSel == 1'b0 ? checksumReg[2] :
              tchecksum[2]);
  assign newChecksum[3] = (csSel == 1'b0 ? checksumReg[3] :
              tchecksum[3]);
  assign newChecksum[4] = (csSel == 1'b0 ? checksumReg[4] :
              tchecksum[4]);
  assign newChecksum[5] = (csSel == 1'b0 ? checksumReg[5] :
              tchecksum[5]);
  assign newChecksum[6] = (csSel == 1'b0 ? checksumReg[6] :
              tchecksum[6]);
  assign newChecksum[7] = (csSel == 1'b0 ? checksumReg[7] :
              tchecksum[7]);
  assign newChecksum[8] = (csSel == 1'b0 ? checksumReg[8] :
              tchecksum[8]);
  assign newChecksum[9] = (csSel == 1'b0 ? checksumReg[9] :
              tchecksum[9]);
  assign newChecksum[10] = (csSel == 1'b0 ? checksumReg[10] :
              tchecksum[10]);
  assign newChecksum[11] = (csSel == 1'b0 ? checksumReg[11] :
              tchecksum[11]);
  assign newChecksum[12] = (csSel == 1'b0 ? checksumReg[12] :
              tchecksum[12]);
  assign newChecksum[13] = (csSel == 1'b0 ? checksumReg[13] :
              tchecksum[13]);
  assign newChecksum[14] = (csSel == 1'b0 ? checksumReg[14] :
              tchecksum[14]);
  assign newChecksum[15] = (csSel == 1'b0 ? checksumReg[15] :
              tchecksum[15]);



  // Xor after computing the checksum
  assign finalChecksum[0] = (xoredSel == 1'b0 ? newChecksum[0] :
              xoredChecksum[0]);
  assign finalChecksum[1] = (xoredSel == 1'b0 ? newChecksum[1] :
              xoredChecksum[1]);
  assign finalChecksum[2] = (xoredSel == 1'b0 ? newChecksum[2] :
              xoredChecksum[2]);
  assign finalChecksum[3] = (xoredSel == 1'b0 ? newChecksum[3] :
              xoredChecksum[3]);
  assign finalChecksum[4] = (xoredSel == 1'b0 ? newChecksum[4] :
              xoredChecksum[4]);
  assign finalChecksum[5] = (xoredSel == 1'b0 ? newChecksum[5] :
              xoredChecksum[5]);
  assign finalChecksum[6] = (xoredSel == 1'b0 ? newChecksum[6] :
              xoredChecksum[6]);
  assign finalChecksum[7] = (xoredSel == 1'b0 ? newChecksum[7] :
              xoredChecksum[7]);
  assign finalChecksum[8] = (xoredSel == 1'b0 ? newChecksum[8] :
              xoredChecksum[8]);
  assign finalChecksum[9] = (xoredSel == 1'b0 ? newChecksum[9] :
              xoredChecksum[9]);
  assign finalChecksum[10] = (xoredSel == 1'b0 ? newChecksum[10] :
              xoredChecksum[10]);
  assign finalChecksum[11] = (xoredSel == 1'b0 ? newChecksum[11] :
              xoredChecksum[11]);
  assign finalChecksum[12] = (xoredSel == 1'b0 ? newChecksum[12] :
              xoredChecksum[12]);
  assign finalChecksum[13] = (xoredSel == 1'b0 ? newChecksum[13] :
              xoredChecksum[13]);
  assign finalChecksum[14] = (xoredSel == 1'b0 ? newChecksum[14] :
              xoredChecksum[14]);
  assign finalChecksum[15] = (xoredSel == 1'b0 ? newChecksum[15] :
              xoredChecksum[15]);



  // 1
  always @(posedge clk or posedge reset)
    begin : outputchecksum_register_process
      if (reset == 1'b1) begin
        crcChecksum[0] <= 1'b0;
        crcChecksum[1] <= 1'b0;
        crcChecksum[2] <= 1'b0;
        crcChecksum[3] <= 1'b0;
        crcChecksum[4] <= 1'b0;
        crcChecksum[5] <= 1'b0;
        crcChecksum[6] <= 1'b0;
        crcChecksum[7] <= 1'b0;
        crcChecksum[8] <= 1'b0;
        crcChecksum[9] <= 1'b0;
        crcChecksum[10] <= 1'b0;
        crcChecksum[11] <= 1'b0;
        crcChecksum[12] <= 1'b0;
        crcChecksum[13] <= 1'b0;
        crcChecksum[14] <= 1'b0;
        crcChecksum[15] <= 1'b0;
      end
      else begin
        if (enb_1_2_0 && xoredSel) begin
          crcChecksum[0] <= finalChecksum[0];
          crcChecksum[1] <= finalChecksum[1];
          crcChecksum[2] <= finalChecksum[2];
          crcChecksum[3] <= finalChecksum[3];
          crcChecksum[4] <= finalChecksum[4];
          crcChecksum[5] <= finalChecksum[5];
          crcChecksum[6] <= finalChecksum[6];
          crcChecksum[7] <= finalChecksum[7];
          crcChecksum[8] <= finalChecksum[8];
          crcChecksum[9] <= finalChecksum[9];
          crcChecksum[10] <= finalChecksum[10];
          crcChecksum[11] <= finalChecksum[11];
          crcChecksum[12] <= finalChecksum[12];
          crcChecksum[13] <= finalChecksum[13];
          crcChecksum[14] <= finalChecksum[14];
          crcChecksum[15] <= finalChecksum[15];
        end
      end
    end



  assign crcChecksum_0 = crcChecksum[0];

  assign crcChecksum_1 = crcChecksum[1];

  assign crcChecksum_2 = crcChecksum[2];

  assign crcChecksum_3 = crcChecksum[3];

  assign crcChecksum_4 = crcChecksum[4];

  assign crcChecksum_5 = crcChecksum[5];

  assign crcChecksum_6 = crcChecksum[6];

  assign crcChecksum_7 = crcChecksum[7];

  assign crcChecksum_8 = crcChecksum[8];

  assign crcChecksum_9 = crcChecksum[9];

  assign crcChecksum_10 = crcChecksum[10];

  assign crcChecksum_11 = crcChecksum[11];

  assign crcChecksum_12 = crcChecksum[12];

  assign crcChecksum_13 = crcChecksum[13];

  assign crcChecksum_14 = crcChecksum[14];

  assign crcChecksum_15 = crcChecksum[15];

endmodule  // whdlOFDMTx_CRCGenCompute_block

