// -------------------------------------------------------------
// 
// File Name: D:\NU\OF\WHDLOFDMTransmitterExample_all_new\hdl_prj\hdlsrc3\whdlOFDMTransmitter_up_con\whdlOFDMTx\whdlOFDMTx_Header_Formation.v
// Created: 2023-05-02 12:36:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: whdlOFDMTx_Header_Formation
// Source Path: whdlOFDMTx/Frame Generator/Header/Header Formation
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module whdlOFDMTx_Header_Formation
          (clk,
           reset,
           enb_1_2_0,
           modType,
           codeRate,
           fftLen,
           validIn,
           headerBits,
           startOut,
           endOut,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_2_0;
  input   [1:0] modType;  // ufix2
  input   [1:0] codeRate;  // ufix2
  input   [2:0] fftLen;  // ufix3
  input   validIn;
  output  headerBits;
  output  startOut;
  output  endOut;
  output  validOut;


  reg  headerBits_1;
  reg  startOut_1;
  reg  endOut_1;
  reg  validOut_1;
  reg [1:0] modReg;  // ufix2
  reg [1:0] codeReg;  // ufix2
  reg [2:0] fftReg;  // ufix3
  reg  validReg;
  reg  startInt;
  reg  [0:1] startO;  // boolean [2]
  reg  endO;
  reg  [0:1] validO;  // boolean [2]
  reg [3:0] count;  // ufix4
  reg [3:0] countReg [0:1];  // ufix4 [2]
  reg  [0:13] buffer1;  // boolean [14]
  reg  [0:13] buffer2;  // boolean [14]
  reg [1:0] modReg_next;  // ufix2
  reg [1:0] codeReg_next;  // ufix2
  reg [2:0] fftReg_next;  // ufix3
  reg  validReg_next;
  reg  startInt_next;
  reg  [0:1] startO_next;  // boolean [2]
  reg  endO_next;
  reg  [0:1] validO_next;  // boolean [2]
  reg [3:0] count_next;  // ufix4
  reg [3:0] countReg_next [0:1];  // ufix4 [2]
  reg  [0:13] buffer1_next;  // boolean [14]
  reg  [0:13] buffer2_next;  // boolean [14]
  reg  startInt_temp;
  reg [3:0] count_temp;  // ufix4
  reg  map [0:2] [0:7];  // boolean [3x8]
  reg signed [31:0] extend_temp;  // int32
  reg signed [31:0] extend_temp_0;  // int32
  reg signed [31:0] extend_temp_1;  // int32
  reg signed [31:0] t_0;  // int32
  reg signed [31:0] t_1;  // int32
  reg signed [31:0] t_2;  // int32
  reg signed [31:0] t_3;  // int32
  reg signed [31:0] t_4;  // int32
  reg signed [31:0] t_5;  // int32
  reg  t_6 [0:2] [0:7];  // boolean [3x8]
  reg [4:0] add_temp;  // ufix5
  reg [3:0] add_temp_0;  // ufix4
  reg [2:0] add_temp_1;  // ufix3
  reg [2:0] add_temp_2;  // ufix3
  reg [4:0] t_7;  // ufix5
  reg [3:0] t_8;  // ufix4
  reg [2:0] t_9;  // ufix3
  reg [2:0] t_10;  // ufix3
  reg signed [31:0] i;  // int32
  reg signed [31:0] i2;  // int32
  reg signed [31:0] t_0_0;  // int32
  reg signed [31:0] t_1_0;  // int32
  reg signed [31:0] t_2_0;  // int32
  reg signed [31:0] t_3_0;  // int32


  always @(posedge clk or posedge reset)
    begin : Header_Formation_process
      if (reset == 1'b1) begin
        modReg <= 2'b00;
        codeReg <= 2'b00;
        fftReg <= 3'b000;
        validReg <= 1'b0;
        startInt <= 1'b0;
        endO <= 1'b0;
        count <= 4'b0001;

        for(t_2_0 = 32'sd0; t_2_0 <= 32'sd1; t_2_0 = t_2_0 + 32'sd1) begin
          startO[t_2_0] <= 1'b0;
          validO[t_2_0] <= 1'b0;
          countReg[t_2_0] <= 4'b0001;
        end


        for(t_3_0 = 32'sd0; t_3_0 <= 32'sd13; t_3_0 = t_3_0 + 32'sd1) begin
          buffer1[t_3_0] <= 1'b0;
          buffer2[t_3_0] <= 1'b0;
        end

      end
      else begin
        if (enb_1_2_0) begin
          modReg <= modReg_next;
          codeReg <= codeReg_next;
          fftReg <= fftReg_next;
          validReg <= validReg_next;
          startInt <= startInt_next;
          endO <= endO_next;
          count <= count_next;

          for(t_0_0 = 32'sd0; t_0_0 <= 32'sd1; t_0_0 = t_0_0 + 32'sd1) begin
            startO[t_0_0] <= startO_next[t_0_0];
            validO[t_0_0] <= validO_next[t_0_0];
            countReg[t_0_0] <= countReg_next[t_0_0];
          end


          for(t_1_0 = 32'sd0; t_1_0 <= 32'sd13; t_1_0 = t_1_0 + 32'sd1) begin
            buffer1[t_1_0] <= buffer1_next[t_1_0];
            buffer2[t_1_0] <= buffer2_next[t_1_0];
          end

        end
      end
    end

  always @* begin
    t_6[0][0] = 1'b0;
    t_6[1][0] = 1'b0;
    t_6[2][0] = 1'b0;
    t_6[0][1] = 1'b0;
    t_6[1][1] = 1'b0;
    t_6[2][1] = 1'b1;
    t_6[0][2] = 1'b0;
    t_6[1][2] = 1'b1;
    t_6[2][2] = 1'b0;
    t_6[0][3] = 1'b0;
    t_6[1][3] = 1'b1;
    t_6[2][3] = 1'b1;
    t_6[0][4] = 1'b1;
    t_6[1][4] = 1'b0;
    t_6[2][4] = 1'b0;
    t_6[0][5] = 1'b1;
    t_6[1][5] = 1'b0;
    t_6[2][5] = 1'b1;
    t_6[0][6] = 1'b1;
    t_6[1][6] = 1'b1;
    t_6[2][6] = 1'b0;
    t_6[0][7] = 1'b1;
    t_6[1][7] = 1'b1;
    t_6[2][7] = 1'b1;
    add_temp = 5'b00000;
    add_temp_0 = 4'b0000;
    add_temp_1 = 3'b000;
    add_temp_2 = 3'b000;
    extend_temp = 32'sd0;
    extend_temp_0 = 32'sd0;
    extend_temp_1 = 32'sd0;
    t_7 = 5'b00000;
    t_8 = 4'b0000;
    t_9 = 3'b000;
    t_10 = 3'b000;

    for(i = 32'sd0; i <= 32'sd7; i = i + 32'sd1) begin
      for(i2 = 32'sd0; i2 <= 32'sd2; i2 = i2 + 32'sd1) begin
        map[i2][i] = t_6[i2][i];
      end
    end

    startInt_temp = startInt;
    count_temp = count;

    for(t_0 = 32'sd0; t_0 <= 32'sd1; t_0 = t_0 + 32'sd1) begin
      startO_next[t_0] = startO[t_0];
      validO_next[t_0] = validO[t_0];
      countReg_next[t_0] = countReg[t_0];
    end


    for(t_1 = 32'sd0; t_1 <= 32'sd13; t_1 = t_1 + 32'sd1) begin
      buffer1_next[t_1] = buffer1[t_1];
    end

    // This function takes fftLen, modType and codeRate inputs to form Header Bits
    // NHeaderBits is the total number of Header Bits formed
    // Assign outputs
    // Generate start, end control signals    
    endO_next = count == 4'b1110;
    if (startInt) begin
      if (count == 4'b1110) begin
        startInt_temp = 1'b0;
        count_temp = 4'b0001;
      end
      else begin
        t_7 = {1'b0, count};
        add_temp = t_7 + 5'b00001;
        if (add_temp[4] != 1'b0) begin
          count_temp = 4'b1111;
        end
        else begin
          count_temp = add_temp[3:0];
        end
      end
    end
    startO_next[1] = startO[0];
    validO_next[1] = validO[0];

    for(t_2 = 32'sd0; t_2 <= 32'sd13; t_2 = t_2 + 32'sd1) begin
      buffer2_next[t_2] = buffer1[t_2];
    end

    countReg_next[1] = countReg[0];
    // Form Header bits based on stored register values and generate valid signal
    if (validReg) begin
      count_temp = 4'b0001;
      startInt_temp = 1'b1;
      t_8 = {1'b0, fftReg};
      add_temp_0 = t_8 + 4'b0001;
      extend_temp = {28'b0, add_temp_0};

      for(t_3 = 32'sd0; t_3 <= 32'sd2; t_3 = t_3 + 32'sd1) begin
        buffer1_next[t_3] = map[t_3][extend_temp - 32'sd1];
      end

      // Form 3 fftBits based on 'fftLen' input
      t_9 = {1'b0, modReg};
      add_temp_1 = t_9 + 3'b001;
      extend_temp_0 = {29'b0, add_temp_1};
      // Form 2 modBits based on 'modType' input
      t_10 = {1'b0, codeReg};
      add_temp_2 = t_10 + 3'b001;
      extend_temp_1 = {29'b0, add_temp_2};

      for(t_4 = 32'sd0; t_4 <= 32'sd1; t_4 = t_4 + 32'sd1) begin
        buffer1_next[32'sd3 + t_4] = map[32'sd1 + t_4][extend_temp_0 - 32'sd1];
        buffer1_next[32'sd5 + t_4] = map[32'sd1 + t_4][extend_temp_1 - 32'sd1];
      end

      // Form 2 codeBits based on 'codeRate' input

      for(t_5 = 32'sd0; t_5 <= 32'sd6; t_5 = t_5 + 32'sd1) begin
        buffer1_next[32'sd7 + t_5] = 1'b0;
      end

      // Append 15 nullBits available for future use
    end
    startO_next[0] = validReg;
    validO_next[0] = startInt_temp;
    countReg_next[0] = count_temp;
    // Store inputs in registers
    modReg_next = modType;
    codeReg_next = codeRate;
    fftReg_next = fftLen;
    validReg_next = validIn;
    headerBits_1 = buffer2[$signed({1'b0, countReg[1]}) - 32'sd1];
    startOut_1 = startO[1];
    endOut_1 = endO;
    validOut_1 = validO[1];
    startInt_next = startInt_temp;
    count_next = count_temp;
  end



  assign headerBits = headerBits_1;

  assign startOut = startOut_1;

  assign endOut = endOut_1;

  assign validOut = validOut_1;

endmodule  // whdlOFDMTx_Header_Formation

