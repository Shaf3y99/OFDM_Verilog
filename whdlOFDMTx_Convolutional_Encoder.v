// -------------------------------------------------------------
// 
// File Name: D:\NU\OF\WHDLOFDMTransmitterExample_all_new\hdl_prj\hdlsrc3\whdlOFDMTransmitter_up_con\whdlOFDMTx\whdlOFDMTx_Convolutional_Encoder.v
// Created: 2023-05-02 12:36:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: whdlOFDMTx_Convolutional_Encoder
// Source Path: whdlOFDMTx/Frame Generator/Data/Data Chain/Convolutional Encoder
// Hierarchy Level: 5
// 
// ConvolutionalEncoder
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module whdlOFDMTx_Convolutional_Encoder
          (clk,
           reset,
           enb_1_2_0,
           in0,
           in1_start,
           in1_end,
           in1_valid,
           out0_0,
           out0_1,
           out1_start,
           out1_end,
           out1_valid);


  input   clk;
  input   reset;
  input   enb_1_2_0;
  input   in0;
  input   in1_start;
  input   in1_end;
  input   in1_valid;
  output  out0_0;
  output  out0_1;
  output  out1_start;
  output  out1_end;
  output  out1_valid;


  wire rstSig;  // ufix1
  wire endSig;  // ufix1
  wire enbSig;  // ufix1
  wire tailFlag;  // ufix1
  reg  datainReg_1;  // ufix1
  wire tailbit;  // ufix1
  wire bittmp;  // ufix1
  reg  bitinreg_1;  // ufix1
  reg  [0:5] shiftreg;  // ufix1 [6]
  wire [0:5] shiftreg_next;  // ufix1 [6]
  wire shiftreg_0;  // ufix1
  wire shiftreg_1_1;  // ufix1
  wire shiftreg_2;  // ufix1
  wire shiftreg_5;  // ufix1
  wire encoded_entry1;  // ufix1
  wire shiftreg_4;  // ufix1
  wire encoded_entry2;  // ufix1
  wire [0:1] encoded;  // ufix1 [2]
  reg  [0:1] dataOut;  // boolean [2]
  reg  startOutd_1;  // ufix1
  reg  startOut_1;
  reg  endOutd_1;  // ufix1
  reg  endOut_1;
  reg  validOutd_1;  // ufix1
  reg  validOut_1;


  // Instantiation of Frame Controller Network
  whdlOFDMTx_controlUnit u_FrameController_inst (.clk(clk),
                                                 .reset(reset),
                                                 .enb_1_2_0(enb_1_2_0),
                                                 .startIn(in1_start),
                                                 .endIn(in1_end),
                                                 .validIn(in1_valid),
                                                 .rstSig(rstSig),  // ufix1
                                                 .endSig(endSig),  // ufix1
                                                 .enbSig(enbSig),  // ufix1
                                                 .tailFlag(tailFlag)  // ufix1
                                                 );

  // register the datain signal
  always @(posedge clk or posedge reset)
    begin : datainreg_process
      if (reset == 1'b1) begin
        datainReg_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          datainReg_1 <= in0;
        end
      end
    end



  assign tailbit = 1'b0;



  // tail or data bits to the encoder
  assign bittmp = (tailFlag == 1'b0 ? datainReg_1 :
              tailbit);



  // delay the bitin signal
  always @(posedge clk or posedge reset)
    begin : bitinreg_process
      if (reset == 1'b1) begin
        bitinreg_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0 && enbSig) begin
          bitinreg_1 <= bittmp;
        end
      end
    end



  assign shiftreg_next[0] = bitinreg_1;
  assign shiftreg_next[1] = shiftreg[0];
  assign shiftreg_next[2] = shiftreg[1];
  assign shiftreg_next[3] = shiftreg[2];
  assign shiftreg_next[4] = shiftreg[3];
  assign shiftreg_next[5] = shiftreg[4];

  // update shift registers
  always @(posedge clk or posedge reset)
    begin : shiftreg_1_process
      if (reset == 1'b1) begin
        shiftreg[0] <= 1'b0;
        shiftreg[1] <= 1'b0;
        shiftreg[2] <= 1'b0;
        shiftreg[3] <= 1'b0;
        shiftreg[4] <= 1'b0;
        shiftreg[5] <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          if (rstSig == 1'b1) begin
            shiftreg[0] <= 1'b0;
            shiftreg[1] <= 1'b0;
            shiftreg[2] <= 1'b0;
            shiftreg[3] <= 1'b0;
            shiftreg[4] <= 1'b0;
            shiftreg[5] <= 1'b0;
          end
          else begin
            if (enbSig) begin
              shiftreg[0] <= shiftreg_next[0];
              shiftreg[1] <= shiftreg_next[1];
              shiftreg[2] <= shiftreg_next[2];
              shiftreg[3] <= shiftreg_next[3];
              shiftreg[4] <= shiftreg_next[4];
              shiftreg[5] <= shiftreg_next[5];
            end
          end
        end
      end
    end



  assign shiftreg_0 = shiftreg[0];

  assign shiftreg_1_1 = shiftreg[1];

  assign shiftreg_2 = shiftreg[2];

  assign shiftreg_5 = shiftreg[5];

  assign encoded_entry1 = shiftreg_5 ^ (shiftreg_2 ^ (shiftreg_1_1 ^ (bitinreg_1 ^ shiftreg_0)));



  assign shiftreg_4 = shiftreg[4];

  // encoded output
  assign encoded_entry2 = shiftreg_5 ^ (shiftreg_4 ^ (shiftreg_2 ^ (bitinreg_1 ^ shiftreg_1_1)));



  assign encoded[0] = encoded_entry1;
  assign encoded[1] = encoded_entry2;

  // register output signal
  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        dataOut[0] <= 1'b0;
        dataOut[1] <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          dataOut[0] <= encoded[0];
          dataOut[1] <= encoded[1];
        end
      end
    end



  assign out0_0 = dataOut[0];

  assign out0_1 = dataOut[1];

  // delay balancing the start signal
  always @(posedge clk or posedge reset)
    begin : startOutd_process
      if (reset == 1'b1) begin
        startOutd_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          startOutd_1 <= rstSig;
        end
      end
    end



  // register start out signal
  always @(posedge clk or posedge reset)
    begin : startout_process
      if (reset == 1'b1) begin
        startOut_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          startOut_1 <= startOutd_1;
        end
      end
    end



  assign out1_start = startOut_1;

  // delay balancing the end signal
  always @(posedge clk or posedge reset)
    begin : endOutd_process
      if (reset == 1'b1) begin
        endOutd_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          endOutd_1 <= endSig;
        end
      end
    end



  // register end out signal
  always @(posedge clk or posedge reset)
    begin : endout_process
      if (reset == 1'b1) begin
        endOut_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          endOut_1 <= endOutd_1;
        end
      end
    end



  assign out1_end = endOut_1;

  // delay balancing the valid signal
  always @(posedge clk or posedge reset)
    begin : validOutd_process
      if (reset == 1'b1) begin
        validOutd_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          validOutd_1 <= enbSig;
        end
      end
    end



  // register valid out signal
  always @(posedge clk or posedge reset)
    begin : validout_process
      if (reset == 1'b1) begin
        validOut_1 <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          validOut_1 <= validOutd_1;
        end
      end
    end



  assign out1_valid = validOut_1;

endmodule  // whdlOFDMTx_Convolutional_Encoder

