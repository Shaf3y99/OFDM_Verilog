// -------------------------------------------------------------
// 
// File Name: D:\NU\OF\WHDLOFDMTransmitterExample_all_new\hdl_prj\hdlsrc3\whdlOFDMTransmitter_up_con\whdlOFDMTx\whdlOFDMTx_Frame_Generator.v
// Created: 2023-05-02 12:36:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: whdlOFDMTx_Frame_Generator
// Source Path: whdlOFDMTx/Frame Generator
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module whdlOFDMTx_Frame_Generator
          (clk,
           reset,
           enb,
           enb_1_2_0,
           preambleSet,
           headerSet,
           modTypeIndex,
           codeRateIndex,
           trBlkSize,
           loadSymMod,
           dataSet,
           resetRAM,
           dataIn,
           validIn,
           ss_re,
           ss_im,
           ssValid,
           rs,
           rsValid,
           pilot,
           pilotValid,
           header_re,
           header_im,
           headerValid,
           data_re,
           data_im,
           dataValid);


  input   clk;
  input   reset;
  input   enb;
  input   enb_1_2_0;
  input   preambleSet;
  input   headerSet;
  input   [1:0] modTypeIndex;  // ufix2
  input   [1:0] codeRateIndex;  // ufix2
  input   [13:0] trBlkSize;  // ufix14
  input   loadSymMod;
  input   dataSet;
  input   resetRAM;
  input   dataIn;
  input   validIn;
  output  signed [15:0] ss_re;  // sfix16_En14
  output  signed [15:0] ss_im;  // sfix16_En14
  output  ssValid;
  output  signed [15:0] rs;  // sfix16_En14
  output  rsValid;
  output  signed [15:0] pilot;  // sfix16_En14
  output  pilotValid;
  output  signed [15:0] header_re;  // sfix16_En14
  output  signed [15:0] header_im;  // sfix16_En14
  output  headerValid;
  output  signed [15:0] data_re;  // sfix16_En14
  output  signed [15:0] data_im;  // sfix16_En14
  output  dataValid;


  wire Generate_Preamble_Control_Signals_out1;
  wire Generate_Preamble_Control_Signals_out2;
  wire Generate_Preamble_Control_Signals_out3;
  wire signed [15:0] Synchronization_Sequence_out1_re;  // sfix16_En14
  wire signed [15:0] Synchronization_Sequence_out1_im;  // sfix16_En14
  wire Synchronization_Sequence_out2;
  reg signed [15:0] Delay1_reg_re [0:1];  // sfix16_En14 [2]
  reg signed [15:0] Delay1_reg_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay1_reg_next_re [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay1_reg_next_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay1_out1_re;  // sfix16_En14
  wire signed [15:0] Delay1_out1_im;  // sfix16_En14
  reg  [0:1] Delay2_reg;  // ufix1 [2]
  wire [0:1] Delay2_reg_next;  // ufix1 [2]
  wire Delay2_out1;
  wire signed [15:0] Reference_Signals_out1;  // sfix16_En14
  wire Reference_Signals_out2;
  reg signed [15:0] Delay3_reg [0:1];  // sfix16 [2]
  wire signed [15:0] Delay3_reg_next [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay3_out1;  // sfix16_En14
  reg  [0:1] Delay4_reg;  // ufix1 [2]
  wire [0:1] Delay4_reg_next;  // ufix1 [2]
  wire Delay4_out1;
  wire signed [15:0] Pilot_out1;  // sfix16_En14
  wire Pilot_out2;
  reg signed [15:0] Delay11_reg [0:1];  // sfix16 [2]
  wire signed [15:0] Delay11_reg_next [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay11_out1;  // sfix16_En14
  reg  [0:1] Delay12_reg;  // ufix1 [2]
  wire [0:1] Delay12_reg_next;  // ufix1 [2]
  wire Delay12_out1;
  wire [2:0] Constant_out1;  // ufix3
  wire signed [15:0] Header_out1_re;  // sfix16_En14
  wire signed [15:0] Header_out1_im;  // sfix16_En14
  wire Header_out2;
  reg signed [15:0] Delay13_reg_re [0:1];  // sfix16_En14 [2]
  reg signed [15:0] Delay13_reg_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay13_reg_next_re [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay13_reg_next_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay13_out1_re;  // sfix16_En14
  wire signed [15:0] Delay13_out1_im;  // sfix16_En14
  reg  [0:1] Delay14_reg;  // ufix1 [2]
  wire [0:1] Delay14_reg_next;  // ufix1 [2]
  wire Delay14_out1;
  wire signed [15:0] Data_out1_re;  // sfix16_En14
  wire signed [15:0] Data_out1_im;  // sfix16_En14
  wire Data_out2;
  reg signed [15:0] Delay15_reg_re [0:1];  // sfix16_En14 [2]
  reg signed [15:0] Delay15_reg_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay15_reg_next_re [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay15_reg_next_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay15_out1_re;  // sfix16_En14
  wire signed [15:0] Delay15_out1_im;  // sfix16_En14
  reg  [0:1] Delay10_reg;  // ufix1 [2]
  wire [0:1] Delay10_reg_next;  // ufix1 [2]
  wire Delay10_out1;


  whdlOFDMTx_Generate_Preamble_Control_Signals u_Generate_Preamble_Control_Signals (.clk(clk),
                                                                                    .reset(reset),
                                                                                    .enb_1_2_0(enb_1_2_0),
                                                                                    .preambleSet(preambleSet),
                                                                                    .ss_set(Generate_Preamble_Control_Signals_out1),
                                                                                    .rs_set(Generate_Preamble_Control_Signals_out2),
                                                                                    .pilot_set(Generate_Preamble_Control_Signals_out3)
                                                                                    );

  whdlOFDMTx_Synchronization_Sequence u_Synchronization_Sequence (.clk(clk),
                                                                  .reset(reset),
                                                                  .enb(enb),
                                                                  .enb_1_2_0(enb_1_2_0),
                                                                  .ss_set(Generate_Preamble_Control_Signals_out1),
                                                                  .ss_re(Synchronization_Sequence_out1_re),  // sfix16_En14
                                                                  .ss_im(Synchronization_Sequence_out1_im),  // sfix16_En14
                                                                  .ssValid(Synchronization_Sequence_out2)
                                                                  );

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg_re[0] <= 16'sb0000000000000000;
        Delay1_reg_im[0] <= 16'sb0000000000000000;
        Delay1_reg_re[1] <= 16'sb0000000000000000;
        Delay1_reg_im[1] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_reg_re[0] <= Delay1_reg_next_re[0];
          Delay1_reg_im[0] <= Delay1_reg_next_im[0];
          Delay1_reg_re[1] <= Delay1_reg_next_re[1];
          Delay1_reg_im[1] <= Delay1_reg_next_im[1];
        end
      end
    end

  assign Delay1_out1_re = Delay1_reg_re[1];
  assign Delay1_out1_im = Delay1_reg_im[1];
  assign Delay1_reg_next_re[0] = Synchronization_Sequence_out1_re;
  assign Delay1_reg_next_im[0] = Synchronization_Sequence_out1_im;
  assign Delay1_reg_next_re[1] = Delay1_reg_re[0];
  assign Delay1_reg_next_im[1] = Delay1_reg_im[0];



  assign ss_re = Delay1_out1_re;

  assign ss_im = Delay1_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg[0] <= 1'b0;
        Delay2_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_reg[0] <= Delay2_reg_next[0];
          Delay2_reg[1] <= Delay2_reg_next[1];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[1];
  assign Delay2_reg_next[0] = Synchronization_Sequence_out2;
  assign Delay2_reg_next[1] = Delay2_reg[0];



  assign ssValid = Delay2_out1;

  whdlOFDMTx_Reference_Signals u_Reference_Signals (.clk(clk),
                                                    .reset(reset),
                                                    .enb(enb),
                                                    .enb_1_2_0(enb_1_2_0),
                                                    .rs_set(Generate_Preamble_Control_Signals_out2),
                                                    .rs(Reference_Signals_out1),  // sfix16_En14
                                                    .rsValid(Reference_Signals_out2)
                                                    );

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg[0] <= 16'sb0000000000000000;
        Delay3_reg[1] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_reg[0] <= Delay3_reg_next[0];
          Delay3_reg[1] <= Delay3_reg_next[1];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[1];
  assign Delay3_reg_next[0] = Reference_Signals_out1;
  assign Delay3_reg_next[1] = Delay3_reg[0];



  assign rs = Delay3_out1;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg[0] <= 1'b0;
        Delay4_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= Delay4_reg_next[0];
          Delay4_reg[1] <= Delay4_reg_next[1];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[1];
  assign Delay4_reg_next[0] = Reference_Signals_out2;
  assign Delay4_reg_next[1] = Delay4_reg[0];



  assign rsValid = Delay4_out1;

  whdlOFDMTx_Pilot u_Pilot (.clk(clk),
                            .reset(reset),
                            .enb(enb),
                            .enb_1_2_0(enb_1_2_0),
                            .pilot_set(Generate_Preamble_Control_Signals_out3),
                            .pilot(Pilot_out1),  // sfix16_En14
                            .pilotValid(Pilot_out2)
                            );

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_reg[0] <= 16'sb0000000000000000;
        Delay11_reg[1] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay11_reg[0] <= Delay11_reg_next[0];
          Delay11_reg[1] <= Delay11_reg_next[1];
        end
      end
    end

  assign Delay11_out1 = Delay11_reg[1];
  assign Delay11_reg_next[0] = Pilot_out1;
  assign Delay11_reg_next[1] = Delay11_reg[0];



  assign pilot = Delay11_out1;

  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_reg[0] <= 1'b0;
        Delay12_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay12_reg[0] <= Delay12_reg_next[0];
          Delay12_reg[1] <= Delay12_reg_next[1];
        end
      end
    end

  assign Delay12_out1 = Delay12_reg[1];
  assign Delay12_reg_next[0] = Pilot_out2;
  assign Delay12_reg_next[1] = Delay12_reg[0];



  assign pilotValid = Delay12_out1;

  assign Constant_out1 = 3'b000;



  whdlOFDMTx_Header u_Header (.clk(clk),
                              .reset(reset),
                              .enb(enb),
                              .enb_1_2_0(enb_1_2_0),
                              .headerSet(headerSet),
                              .modTypeIndex(modTypeIndex),  // ufix2
                              .codeRateIndex(codeRateIndex),  // ufix2
                              .fftLenIndex(Constant_out1),  // ufix3
                              .header_re(Header_out1_re),  // sfix16_En14
                              .header_im(Header_out1_im),  // sfix16_En14
                              .headerValid(Header_out2)
                              );

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_reg_re[0] <= 16'sb0000000000000000;
        Delay13_reg_im[0] <= 16'sb0000000000000000;
        Delay13_reg_re[1] <= 16'sb0000000000000000;
        Delay13_reg_im[1] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay13_reg_re[0] <= Delay13_reg_next_re[0];
          Delay13_reg_im[0] <= Delay13_reg_next_im[0];
          Delay13_reg_re[1] <= Delay13_reg_next_re[1];
          Delay13_reg_im[1] <= Delay13_reg_next_im[1];
        end
      end
    end

  assign Delay13_out1_re = Delay13_reg_re[1];
  assign Delay13_out1_im = Delay13_reg_im[1];
  assign Delay13_reg_next_re[0] = Header_out1_re;
  assign Delay13_reg_next_im[0] = Header_out1_im;
  assign Delay13_reg_next_re[1] = Delay13_reg_re[0];
  assign Delay13_reg_next_im[1] = Delay13_reg_im[0];



  assign header_re = Delay13_out1_re;

  assign header_im = Delay13_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_reg[0] <= 1'b0;
        Delay14_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay14_reg[0] <= Delay14_reg_next[0];
          Delay14_reg[1] <= Delay14_reg_next[1];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[1];
  assign Delay14_reg_next[0] = Header_out2;
  assign Delay14_reg_next[1] = Delay14_reg[0];



  assign headerValid = Delay14_out1;

  whdlOFDMTx_Data u_Data (.clk(clk),
                          .reset(reset),
                          .enb(enb),
                          .enb_1_2_0(enb_1_2_0),
                          .dataSet(dataSet),
                          .modTypeIndex(modTypeIndex),  // ufix2
                          .codeRateIndex(codeRateIndex),  // ufix2
                          .loadModulator(loadSymMod),
                          .trBlkSize(trBlkSize),  // ufix14
                          .dataIn(dataIn),
                          .wrEnable(validIn),
                          .resetRAM(resetRAM),
                          .data_re(Data_out1_re),  // sfix16_En14
                          .data_im(Data_out1_im),  // sfix16_En14
                          .valid(Data_out2)
                          );

  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        Delay15_reg_re[0] <= 16'sb0000000000000000;
        Delay15_reg_im[0] <= 16'sb0000000000000000;
        Delay15_reg_re[1] <= 16'sb0000000000000000;
        Delay15_reg_im[1] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay15_reg_re[0] <= Delay15_reg_next_re[0];
          Delay15_reg_im[0] <= Delay15_reg_next_im[0];
          Delay15_reg_re[1] <= Delay15_reg_next_re[1];
          Delay15_reg_im[1] <= Delay15_reg_next_im[1];
        end
      end
    end

  assign Delay15_out1_re = Delay15_reg_re[1];
  assign Delay15_out1_im = Delay15_reg_im[1];
  assign Delay15_reg_next_re[0] = Data_out1_re;
  assign Delay15_reg_next_im[0] = Data_out1_im;
  assign Delay15_reg_next_re[1] = Delay15_reg_re[0];
  assign Delay15_reg_next_im[1] = Delay15_reg_im[0];



  assign data_re = Delay15_out1_re;

  assign data_im = Delay15_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_reg[0] <= 1'b0;
        Delay10_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay10_reg[0] <= Delay10_reg_next[0];
          Delay10_reg[1] <= Delay10_reg_next[1];
        end
      end
    end

  assign Delay10_out1 = Delay10_reg[1];
  assign Delay10_reg_next[0] = Data_out2;
  assign Delay10_reg_next[1] = Delay10_reg[0];



  assign dataValid = Delay10_out1;

endmodule  // whdlOFDMTx_Frame_Generator

