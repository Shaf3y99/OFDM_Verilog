// -------------------------------------------------------------
// 
// File Name: D:\NU\OF\WHDLOFDMTransmitterExample_all_new\hdl_prj\hdlsrc3\whdlOFDMTransmitter_up_con\whdlOFDMTx\whdlOFDMTx_CRCGenControl_block.v
// Created: 2023-05-02 12:36:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: whdlOFDMTx_CRCGenControl_block
// Source Path: whdlOFDMTx/Frame Generator/Header/General CRC Generator HDL Optimized/CRCGenControl
// Hierarchy Level: 5
// 
// CRC Generator Control Signals Generation
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module whdlOFDMTx_CRCGenControl_block
          (clk,
           reset,
           enb_1_2_0,
           startIn,
           endIn,
           validIn,
           startOut,
           processMsg,
           padZero,
           outputCRC,
           endOut,
           validOut,
           counter,
           counter_outputCRC);


  input   clk;
  input   reset;
  input   enb_1_2_0;
  input   startIn;  // ufix1
  input   endIn;  // ufix1
  input   validIn;  // ufix1
  output  startOut;  // ufix1
  output  processMsg;  // ufix1
  output  padZero;  // ufix1
  output  outputCRC;  // ufix1
  output  endOut;  // ufix1
  output  validOut;  // ufix1
  output  [3:0] counter;  // ufix4
  output  [3:0] counter_outputCRC;  // ufix4


  reg  deofin;  // ufix1
  reg [3:0] cnt3out;  // ufix4
  wire processzero_short;  // ufix1
  wire cnt3enb;  // ufix1
  wire tsysenb_short;  // ufix1
  wire tprocessMsg;  // ufix1
  wire sysenb_short;  // ufix1
  wire ready;  // ufix1
  wire cnt1enb;  // ufix1
  reg [3:0] cnt2out;  // ufix4
  wire cnt2rst;  // ufix1
  wire cnt2enb;  // ufix1
  wire compare_cmpOut;
  wire [3:0] cnt2fstout;  // ufix4
  wire cnt2fstout_is_not0;
  wire cnt1rst;  // ufix1
  reg  cnt1out;  // ufix1
  reg  dtprocessMsg;  // ufix1
  wire rdtprocessMsg;  // ufix1
  wire startout_1;  // ufix1
  reg  [0:15] sof_delay_register_reg;  // ufix1 [16]
  wire [0:15] sof_delay_register_reg_next;  // ufix1 [16]
  wire processzero;  // ufix1
  wire tpadZero;  // ufix1
  wire cnt4rst;  // ufix1
  wire cnt5enb;  // ufix1
  reg [3:0] cnt5out;  // ufix4
  reg [3:0] cnt4out;  // ufix4
  reg  dteofout;  // ufix1
  wire rdteofout;  // ufix1
  wire sysenb;  // ufix1
  reg  udvalidin;  // ufix1
  wire rcnt3enb;  // ufix1
  wire clearvalidin;  // ufix1
  wire tvalidout;  // ufix1
  reg  [0:15] tvalidout_delay_register_reg;  // ufix1 [16]
  wire [0:15] tvalidout_delay_register_reg_next;  // ufix1 [16]
  wire dvalidout;  // ufix1


  always @(posedge clk or posedge reset)
    begin : eofin_delay_register_process
      if (reset == 1'b1) begin
        deofin <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          deofin <= endIn;
        end
      end
    end



  assign processzero_short = cnt3out < 4'b1111;



  assign tsysenb_short = cnt3enb & processzero_short;



  assign sysenb_short = tprocessMsg | tsysenb_short;



  assign ready =  ~ sysenb_short;



  assign cnt1enb = ready & startIn;



  // Counter 3 enable signal
  assign cnt3enb = cnt2out >= 4'b0001;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 15
  // Counter3: counts when start to pad zeros
  always @(posedge clk or posedge reset)
    begin : counter_1_process
      if (reset == 1'b1) begin
        cnt3out <= 4'b0000;
      end
      else begin
        if (enb_1_2_0) begin
          if (cnt2rst == 1'b1) begin
            cnt3out <= 4'b0000;
          end
          else if (cnt3enb == 1'b1) begin
            cnt3out <= cnt3out + 4'b0001;
          end
        end
      end
    end



  assign cnt2rst = cnt3out == 4'b1111;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 15
  //  count to value  = 1
  // Counter2: triggered by End of frame signal
  always @(posedge clk or posedge reset)
    begin : counter_2_process
      if (reset == 1'b1) begin
        cnt2out <= 4'b0000;
      end
      else begin
        if (enb_1_2_0) begin
          if (cnt2rst == 1'b1) begin
            cnt2out <= 4'b0000;
          end
          else if (cnt2enb == 1'b1) begin
            if (cnt2out == 4'b0001) begin
              cnt2out <= 4'b0000;
            end
            else begin
              cnt2out <= cnt2out + 4'b1111;
            end
          end
        end
      end
    end



  assign compare_cmpOut = cnt2out == 4'b0000;



  assign cnt2fstout = {3'b0, compare_cmpOut};



  assign cnt2fstout_is_not0 = cnt2fstout != 4'b0000;



  // Counter 2 enable signal
  assign cnt2enb = tprocessMsg & deofin;



  assign cnt1rst = cnt2enb & cnt2fstout_is_not0;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Counter1: triggered by Start of frame signal
  always @(posedge clk or posedge reset)
    begin : counter_3_process
      if (reset == 1'b1) begin
        cnt1out <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          if (cnt1rst == 1'b1) begin
            cnt1out <= 1'b0;
          end
          else if (cnt1enb == 1'b1) begin
            cnt1out <=  ~ cnt1out;
          end
        end
      end
    end



  assign tprocessMsg = cnt1out == 1'b1;



  always @(posedge clk or posedge reset)
    begin : tprocessMsg_delay_register_process
      if (reset == 1'b1) begin
        dtprocessMsg <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          dtprocessMsg <= tprocessMsg;
        end
      end
    end



  assign rdtprocessMsg =  ~ dtprocessMsg;



  assign startout_1 = tprocessMsg & rdtprocessMsg;



  // Start of frame output signal
  always @(posedge clk or posedge reset)
    begin : sof_delay_register_process
      if (reset == 1'b1) begin
        sof_delay_register_reg[0] <= 1'b0;
        sof_delay_register_reg[1] <= 1'b0;
        sof_delay_register_reg[2] <= 1'b0;
        sof_delay_register_reg[3] <= 1'b0;
        sof_delay_register_reg[4] <= 1'b0;
        sof_delay_register_reg[5] <= 1'b0;
        sof_delay_register_reg[6] <= 1'b0;
        sof_delay_register_reg[7] <= 1'b0;
        sof_delay_register_reg[8] <= 1'b0;
        sof_delay_register_reg[9] <= 1'b0;
        sof_delay_register_reg[10] <= 1'b0;
        sof_delay_register_reg[11] <= 1'b0;
        sof_delay_register_reg[12] <= 1'b0;
        sof_delay_register_reg[13] <= 1'b0;
        sof_delay_register_reg[14] <= 1'b0;
        sof_delay_register_reg[15] <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          sof_delay_register_reg[0] <= sof_delay_register_reg_next[0];
          sof_delay_register_reg[1] <= sof_delay_register_reg_next[1];
          sof_delay_register_reg[2] <= sof_delay_register_reg_next[2];
          sof_delay_register_reg[3] <= sof_delay_register_reg_next[3];
          sof_delay_register_reg[4] <= sof_delay_register_reg_next[4];
          sof_delay_register_reg[5] <= sof_delay_register_reg_next[5];
          sof_delay_register_reg[6] <= sof_delay_register_reg_next[6];
          sof_delay_register_reg[7] <= sof_delay_register_reg_next[7];
          sof_delay_register_reg[8] <= sof_delay_register_reg_next[8];
          sof_delay_register_reg[9] <= sof_delay_register_reg_next[9];
          sof_delay_register_reg[10] <= sof_delay_register_reg_next[10];
          sof_delay_register_reg[11] <= sof_delay_register_reg_next[11];
          sof_delay_register_reg[12] <= sof_delay_register_reg_next[12];
          sof_delay_register_reg[13] <= sof_delay_register_reg_next[13];
          sof_delay_register_reg[14] <= sof_delay_register_reg_next[14];
          sof_delay_register_reg[15] <= sof_delay_register_reg_next[15];
        end
      end
    end

  assign startOut = sof_delay_register_reg[15];
  assign sof_delay_register_reg_next[0] = startout_1;
  assign sof_delay_register_reg_next[1] = sof_delay_register_reg[0];
  assign sof_delay_register_reg_next[2] = sof_delay_register_reg[1];
  assign sof_delay_register_reg_next[3] = sof_delay_register_reg[2];
  assign sof_delay_register_reg_next[4] = sof_delay_register_reg[3];
  assign sof_delay_register_reg_next[5] = sof_delay_register_reg[4];
  assign sof_delay_register_reg_next[6] = sof_delay_register_reg[5];
  assign sof_delay_register_reg_next[7] = sof_delay_register_reg[6];
  assign sof_delay_register_reg_next[8] = sof_delay_register_reg[7];
  assign sof_delay_register_reg_next[9] = sof_delay_register_reg[8];
  assign sof_delay_register_reg_next[10] = sof_delay_register_reg[9];
  assign sof_delay_register_reg_next[11] = sof_delay_register_reg[10];
  assign sof_delay_register_reg_next[12] = sof_delay_register_reg[11];
  assign sof_delay_register_reg_next[13] = sof_delay_register_reg[12];
  assign sof_delay_register_reg_next[14] = sof_delay_register_reg[13];
  assign sof_delay_register_reg_next[15] = sof_delay_register_reg[14];



  // processMsg
  assign processMsg = tprocessMsg;



  assign processzero = 1'b1;



  assign tpadZero = cnt3enb & processzero;



  // padZero
  assign padZero = tpadZero;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 15
  // Counter5: counts when start to output CRC
  always @(posedge clk or posedge reset)
    begin : counter_4_process
      if (reset == 1'b1) begin
        cnt5out <= 4'b0000;
      end
      else begin
        if (enb_1_2_0) begin
          if (cnt4rst == 1'b1) begin
            cnt5out <= 4'b0000;
          end
          else if (cnt5enb == 1'b1) begin
            cnt5out <= cnt5out + 4'b0001;
          end
        end
      end
    end



  assign cnt4rst = cnt5out == 4'b1111;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 15
  // Counter4: triggered after processing all the padded zeros
  always @(posedge clk or posedge reset)
    begin : counter_5_process
      if (reset == 1'b1) begin
        cnt4out <= 4'b0000;
      end
      else begin
        if (enb_1_2_0) begin
          if (cnt4rst == 1'b1) begin
            cnt4out <= 4'b0000;
          end
          else if (cnt2rst == 1'b1) begin
            cnt4out <= cnt4out + 4'b0001;
          end
        end
      end
    end



  // Counter 5 enable signal
  assign cnt5enb = cnt4out >= 4'b0001;



  // outputCRC
  assign outputCRC = cnt5enb;



  always @(posedge clk or posedge reset)
    begin : eofout_delay_register_process
      if (reset == 1'b1) begin
        dteofout <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          dteofout <= cnt4rst;
        end
      end
    end



  assign rdteofout =  ~ dteofout;



  // End of frame output signal
  assign endOut = cnt4rst & rdteofout;



  assign sysenb = tprocessMsg | tpadZero;



  always @(posedge clk or posedge reset)
    begin : validin_unitdelay_register_process
      if (reset == 1'b1) begin
        udvalidin <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          udvalidin <= validIn;
        end
      end
    end



  assign rcnt3enb =  ~ cnt3enb;



  assign clearvalidin = (cnt3enb == 1'b0 ? udvalidin :
              rcnt3enb);



  assign tvalidout = sysenb & clearvalidin;



  // Buffer the validIn signal
  always @(posedge clk or posedge reset)
    begin : tvalidout_delay_register_process
      if (reset == 1'b1) begin
        tvalidout_delay_register_reg[0] <= 1'b0;
        tvalidout_delay_register_reg[1] <= 1'b0;
        tvalidout_delay_register_reg[2] <= 1'b0;
        tvalidout_delay_register_reg[3] <= 1'b0;
        tvalidout_delay_register_reg[4] <= 1'b0;
        tvalidout_delay_register_reg[5] <= 1'b0;
        tvalidout_delay_register_reg[6] <= 1'b0;
        tvalidout_delay_register_reg[7] <= 1'b0;
        tvalidout_delay_register_reg[8] <= 1'b0;
        tvalidout_delay_register_reg[9] <= 1'b0;
        tvalidout_delay_register_reg[10] <= 1'b0;
        tvalidout_delay_register_reg[11] <= 1'b0;
        tvalidout_delay_register_reg[12] <= 1'b0;
        tvalidout_delay_register_reg[13] <= 1'b0;
        tvalidout_delay_register_reg[14] <= 1'b0;
        tvalidout_delay_register_reg[15] <= 1'b0;
      end
      else begin
        if (enb_1_2_0) begin
          tvalidout_delay_register_reg[0] <= tvalidout_delay_register_reg_next[0];
          tvalidout_delay_register_reg[1] <= tvalidout_delay_register_reg_next[1];
          tvalidout_delay_register_reg[2] <= tvalidout_delay_register_reg_next[2];
          tvalidout_delay_register_reg[3] <= tvalidout_delay_register_reg_next[3];
          tvalidout_delay_register_reg[4] <= tvalidout_delay_register_reg_next[4];
          tvalidout_delay_register_reg[5] <= tvalidout_delay_register_reg_next[5];
          tvalidout_delay_register_reg[6] <= tvalidout_delay_register_reg_next[6];
          tvalidout_delay_register_reg[7] <= tvalidout_delay_register_reg_next[7];
          tvalidout_delay_register_reg[8] <= tvalidout_delay_register_reg_next[8];
          tvalidout_delay_register_reg[9] <= tvalidout_delay_register_reg_next[9];
          tvalidout_delay_register_reg[10] <= tvalidout_delay_register_reg_next[10];
          tvalidout_delay_register_reg[11] <= tvalidout_delay_register_reg_next[11];
          tvalidout_delay_register_reg[12] <= tvalidout_delay_register_reg_next[12];
          tvalidout_delay_register_reg[13] <= tvalidout_delay_register_reg_next[13];
          tvalidout_delay_register_reg[14] <= tvalidout_delay_register_reg_next[14];
          tvalidout_delay_register_reg[15] <= tvalidout_delay_register_reg_next[15];
        end
      end
    end

  assign dvalidout = tvalidout_delay_register_reg[15];
  assign tvalidout_delay_register_reg_next[0] = tvalidout;
  assign tvalidout_delay_register_reg_next[1] = tvalidout_delay_register_reg[0];
  assign tvalidout_delay_register_reg_next[2] = tvalidout_delay_register_reg[1];
  assign tvalidout_delay_register_reg_next[3] = tvalidout_delay_register_reg[2];
  assign tvalidout_delay_register_reg_next[4] = tvalidout_delay_register_reg[3];
  assign tvalidout_delay_register_reg_next[5] = tvalidout_delay_register_reg[4];
  assign tvalidout_delay_register_reg_next[6] = tvalidout_delay_register_reg[5];
  assign tvalidout_delay_register_reg_next[7] = tvalidout_delay_register_reg[6];
  assign tvalidout_delay_register_reg_next[8] = tvalidout_delay_register_reg[7];
  assign tvalidout_delay_register_reg_next[9] = tvalidout_delay_register_reg[8];
  assign tvalidout_delay_register_reg_next[10] = tvalidout_delay_register_reg[9];
  assign tvalidout_delay_register_reg_next[11] = tvalidout_delay_register_reg[10];
  assign tvalidout_delay_register_reg_next[12] = tvalidout_delay_register_reg[11];
  assign tvalidout_delay_register_reg_next[13] = tvalidout_delay_register_reg[12];
  assign tvalidout_delay_register_reg_next[14] = tvalidout_delay_register_reg[13];
  assign tvalidout_delay_register_reg_next[15] = tvalidout_delay_register_reg[14];



  // Data valid output
  assign validOut = dvalidout | cnt5enb;



  assign counter = cnt3out;

  assign counter_outputCRC = cnt5out;

endmodule  // whdlOFDMTx_CRCGenControl_block

